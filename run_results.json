{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v5.json", "dbt_version": "1.7.10", "generated_at": "2024-04-25T00:24:38.230216Z", "invocation_id": "6bed57b2-ff50-4c82-b1db-de80f188cb1f", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.101374Z", "completed_at": "2024-04-25T00:24:38.107459Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.108634Z", "completed_at": "2024-04-25T00:24:38.108647Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.009427785873413086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.check_an_agg_for_cp", "compiled": true, "compiled_code": "-- Visualiser les dept et r\u00e9gion pour un CP multi d\u00e9partements\nselect\n    LPAD(CAST(cp.code_postal AS TEXT), 5, '0') as code_postal,\n    cc.\"COM\" as code_commune_insee,\n    cc.\"ARR\" as code_arrondissement,\n    cc.\"DEP\" as code_departement,\n    cc.\"REG\" as code_region\nfrom codes_postaux cp\nleft join codes_geographiques_communes cc on cp.code_commune_insee = cc.\"COM\" and cc.\"TYPECOM\" = 'COM'\nwhere code_postal = '01410'", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.112172Z", "completed_at": "2024-04-25T00:24:38.113829Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.114972Z", "completed_at": "2024-04-25T00:24:38.114978Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005126953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.multiple_agg_per_cp", "compiled": true, "compiled_code": "-- Les departements et les r\u00e9gions sont donn\u00e9es par commune\n-- Il existe plusieurs codes postaux pour une commune et plusieurs communes pour un code postal\n-- Il convient de v\u00e9rifier que pour un code postal donn\u00e9, apr\u00e8s fusion avec la table communes,\n-- Il n'y a pas qu'un seul arrondissement, un seul d\u00e9partement et une seule r\u00e9gion\nwith merged_data as (\n    select\n        LPAD(CAST(cp.code_postal AS TEXT), 5, '0') as code_postal,\n        -- cc.\"ARR\" as code_arrondissement,\n        cc.\"DEP\" as code_departement,\n        cc.\"REG\" as code_region\n    from codes_postaux cp\n    inner join codes_geographiques_communes cc on cp.code_commune_insee = cc.\"COM\" and cc.\"TYPECOM\" = 'COM'\n    -- Remplacer par left join \u00e0 l'inclusions des territoire d'outre mer TOM \n    -- Puisque les codes communes ne sont pas renseign\u00e9s pour ces territoires dans codes_geographiques_communes\n    -- La R\u00e9union est une region d'outre, mais pas un territoire d'outre mer, d\u00e8s lors elle est incluse dans les codes_geographiques_communes\n),\n\ncounts as (\n    select \n        code_postal,\n        --count(distinct code_arrondissement) as num_arr,\n        count(distinct code_departement) as num_dep,\n        count(distinct code_region) as num_reg\n    from merged_data\n    group by code_postal\n)\n\nselect *\nfrom counts\nwhere num_dep > 1 or num_reg > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.118581Z", "completed_at": "2024-04-25T00:24:38.120213Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.121343Z", "completed_at": "2024-04-25T00:24:38.121349Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.004918336868286133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.multiple_com_per_cp", "compiled": true, "compiled_code": "--- Montre les codes postaux qui ont plusieurs codes communes\n\nSELECT code_postal, ARRAY_AGG(DISTINCT code_commune_insee) as communes\nFROM codes_postaux\nGROUP BY code_postal\nHAVING COUNT(DISTINCT code_commune_insee) > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.124758Z", "completed_at": "2024-04-25T00:24:38.126673Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.127793Z", "completed_at": "2024-04-25T00:24:38.127801Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.00511479377746582, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.multiple_cp_per_com", "compiled": true, "compiled_code": "--- Montre les communes qui ont plusieurs codes postaux\n\nSELECT code_commune_insee, ARRAY_AGG(DISTINCT code_postal) as postal_codes\nFROM codes_postaux\nGROUP BY code_commune_insee\nHAVING COUNT(DISTINCT code_postal) > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.131187Z", "completed_at": "2024-04-25T00:24:38.134018Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.135271Z", "completed_at": "2024-04-25T00:24:38.135276Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.006166934967041016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.fake_knn_data", "compiled": true, "compiled_code": "-- Pour tester la fonction knn, nous devons cr\u00e9er une table avec des donn\u00e9es fictives \n-- (impossible de faire des tests unitaires sur des donn\u00e9es qui ne sont pas dans une table). \n-- cr\u00e9e une fausse table avec id, latitude, longitude, et valeur columns\n-- S'assurer que le calcul ne se fait pas sur l'objet de la table\n\n\n\nWITH fake_knn_table AS (\n    SELECT 1 AS id, 43.7 AS latitude, 3.832 AS longitude, 100 AS valeur UNION ALL -- (3, 2) --> (200 + 300) / 2 = 250\n    SELECT 3,       43.7,             3.830,              200 UNION ALL -- (1, 2) --> (100 + 300) / 2 = 200\n    SELECT 2,       43.7,             3.831,              300 UNION ALL -- (1, 3) --> (100 + 200) / 2 = 150\n    SELECT 4,       43.7,             3.839,              400 UNION ALL -- (6, 1) --> (500 + 100) / 2 = 300\n    SELECT 6,       43.7,             3.838,              500  -- (4, 1) --> (400 + 100) / 2 = 250\n)\n\n\nselect * from fake_knn_table", "relation_name": "\"test_db\".\"public\".\"fake_knn_data\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.138735Z", "completed_at": "2024-04-25T00:24:38.141416Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.142590Z", "completed_at": "2024-04-25T00:24:38.142595Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005952358245849609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.geo_communes", "compiled": true, "compiled_code": "/*\n    Merge all data to commune level\n\n\n    Try changing \"table\" to \"view\" below\n*/\n\n\n\nwith filtered_codes_geographiques_communes as (\n    -- Filter out non-commune rows here to avoid confusion of filtering in the main query\n    select * \n    from codes_geographiques_communes     \n    where codes_geographiques_communes.\"TYPECOM\" = 'COM' \n\n), source_data as (\n\n    select\n        f_cgc.\"COM\" as code_commune_insee,\n        f_cgc.\"LIBELLE\" as nom_commune,\n        f_cgc.\"REG\" as code_region,\n        cgr.\"LIBELLE\" as nom_region,\n        f_cgc.\"DEP\" as code_departement,\n        cgd.\"LIBELLE\" as nom_departement,\n        f_cgc.\"ARR\" as code_arrondissement,\n        cga.\"LIBELLE\" as nom_arrondissement\n    from filtered_codes_geographiques_communes f_cgc \n    left join codes_geographiques_arrondissements cga on f_cgc.\"ARR\" = cga.\"ARR\" \n    left join codes_geographiques_departements cgd on f_cgc.\"DEP\" = cgd.\"DEP\" \n    left join codes_geographiques_regions cgr on f_cgc.\"REG\" = cgr.\"REG\"     \n), geopoints as (\n    select DISTINCT\n        LPAD(CAST(cp.code_commune_insee AS TEXT), 5, '0') as code_commune_insee,\n        CAST(SPLIT_PART(cp._geopoint, ',', 1) AS FLOAT) as commune_latitude,\n        CAST(SPLIT_PART(cp._geopoint, ',', 2) AS FLOAT) as commune_longitude\n    from codes_postaux cp\n)\n\nselect\n    sd.*,\n    gp.commune_latitude,\n    gp.commune_longitude\nfrom source_data sd\nleft join geopoints gp on sd.code_commune_insee = gp.code_commune_insee", "relation_name": "\"test_db\".\"public\".\"geo_communes\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.146110Z", "completed_at": "2024-04-25T00:24:38.148761Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.149867Z", "completed_at": "2024-04-25T00:24:38.149872Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005945920944213867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.geo_postaux", "compiled": true, "compiled_code": "/*\n    Merge all data to commune level\n\n\n    Try changing \"table\" to \"view\" below\n*/\n\n\n\nwith source_data as (\n    select DISTINCT\n        LPAD(CAST(code_postal AS TEXT), 5, '0') as code_postal,\n        CASE \n            WHEN SUBSTRING(LPAD(CAST(code_postal AS TEXT), 5, '0') for 3) IN ('200', '201') THEN '2A'\n            WHEN SUBSTRING(LPAD(CAST(code_postal AS TEXT), 5, '0') for 1) = '2' THEN '2B'\n            ELSE SUBSTRING(LPAD(CAST(code_postal AS TEXT), 5, '0') for 2)\n        END as code_departement\n    from codes_postaux\n),\n\njoined_with_departement as (\n    select \n        sd.*,\n        cd.\"LIBELLE\" as nom_departement,\n        cd.\"REG\" as code_region\n    from source_data sd\n    left join codes_geographiques_departements cd on sd.code_departement = cd.\"DEP\"\n),\n\njoined_with_region as (\n    select \n        jd.*,\n        cr.\"LIBELLE\" as nom_region\n    from joined_with_departement jd\n    left join codes_geographiques_regions cr on jd.code_region = cr.\"REG\"\n)\n\nselect *\nfrom joined_with_region", "relation_name": "\"test_db\".\"public\".\"geo_postaux\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.153368Z", "completed_at": "2024-04-25T00:24:38.155970Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.157093Z", "completed_at": "2024-04-25T00:24:38.157099Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005810737609863281, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.geo_postaux_communes", "compiled": true, "compiled_code": "--- Un code postal peut appartenir \u00e0 plusieurs communes\n--- Une code commune insee peut appartenir plusieurs codes postaux\n--- On cr\u00e9e une table de passage pour avoir une relation unique entre les codes postaux et les codes communes insee\n\n\n\nwith unique_codes_communes_postaux as (\n    select DISTINCT\n        LPAD(CAST(code_postal AS TEXT), 5, '0') as code_postal,\n        code_commune_insee\n    from codes_postaux\n)\n\nselect *\nfrom unique_codes_communes_postaux", "relation_name": "\"test_db\".\"public\".\"geo_postaux_communes\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.160507Z", "completed_at": "2024-04-25T00:24:38.163268Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.164385Z", "completed_at": "2024-04-25T00:24:38.164389Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.006136178970336914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.immo_dvf_mutations", "compiled": true, "compiled_code": "-- Filtres nature transaction et nature bien :\n-- Il convient aussi de garder que les vente (explure les VEFA et les \u00e9changes)\n-- Et que les transactions qui concernent au moins un appartement et les maisons\n\n-- Filtres sur les surfaces et trautement des pi\u00e8ces :\n-- Il convient de garder que les transactions qui concernent des biens de plus de 9m2 \n-- Le nombre de pi\u00e8ces est souvent mal renseign\u00e9, il convient de le corriger en fonction de la surface\n\n-- Filtres sur les prix :\n-- Il convient de garder que les transactions dont le prix au metre carr\u00e9 n'est pas 50% de plus que ses 10 plus proches voisins\n\n-- Donn\u00e9es par mutation : \n-- Les donn\u00e9es DVF sont initilement pr\u00e9sent\u00e9es sous forme d'une ligne par mutation (transaction)\n-- Une mutation peut concerner plusieurs biens\n-- Le prix est le prix total de la mutation, il apparait sur les biens concern\u00e9s\n\n\n\nWITH filtered_dvf AS (\n    SELECT \n        id_mutation,\n        valeur_fonciere,\n        longitude,\n        latitude,\n        nombre_pieces_principales,\n        surface_reelle_bati,\n        type_local,\n        LPAD(CAST(code_postal AS TEXT), 5, '0') as code_postal,\n        code_commune\n    FROM \n        dvf\n    WHERE \n        EXISTS (\n            SELECT 1\n            FROM dvf d1\n            WHERE d1.id_mutation = dvf.id_mutation AND d1.type_local IN ('Appartement', 'Maison')\n        ) AND\n        NOT EXISTS (\n            SELECT 1\n            FROM dvf d2\n            WHERE d2.id_mutation = dvf.id_mutation AND d2.nature_mutation != 'Vente'\n        )\n),\nsums AS (\n    SELECT \n        id_mutation,\n        SUM(surface_reelle_bati) AS total_surface,\n        SUM(nombre_pieces_principales) AS total_pieces\n    FROM \n        filtered_dvf\n    GROUP BY \n        id_mutation\n),\n\nranked_dvf AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (\n            PARTITION BY id_mutation\n            ORDER BY \n                CASE WHEN type_local = 'Maison' THEN 1\n                     WHEN type_local = 'Appartement' THEN 2\n                     ELSE 3\n                END,\n                surface_reelle_bati DESC\n        ) AS rn\n    FROM \n        filtered_dvf\n)\n\nSELECT \n    r.id_mutation,\n    r.valeur_fonciere,\n    r.longitude,\n    r.latitude,\n    s.total_pieces,\n    s.total_surface,\n    r.type_local,\n    r.code_postal,\n    r.code_commune\nFROM \n    ranked_dvf r\nJOIN \n    sums s ON r.id_mutation = s.id_mutation\nWHERE \n    r.rn = 1", "relation_name": "\"test_db\".\"public\".\"immo_dvf_mutations\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.167992Z", "completed_at": "2024-04-25T00:24:38.169716Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.170852Z", "completed_at": "2024-04-25T00:24:38.170857Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0049266815185546875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_arr", "compiled": true, "compiled_code": "-- Test qu'il n'ya pas de doublons dans la table des codes g\u00e9ographiques des arrondissements\n\nWITH counts as (\n    select \n        cga.\"ARR\",\n        count(*) as num_arr\n    from codes_geographiques_arrondissements as cga\n    group by cga.\"ARR\"\n)\n\nselect *\nfrom counts\nwhere num_arr > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.174246Z", "completed_at": "2024-04-25T00:24:38.177211Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.178357Z", "completed_at": "2024-04-25T00:24:38.178361Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0062143802642822266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_com", "compiled": true, "compiled_code": "-- Une commune peut avoir plusieurs types\n-- COM\tCommune / COMA\tCommune associ\u00e9e / COMD\tCommune d\u00e9l\u00e9gu\u00e9e / ARM\tArrondissement municipal\n-- Les COM sont celles existantes, les autres types sont des legacy de fusions ou disparitions de communes\n\nWITH counts as (\n    select \n        cgc.\"COM\",\n        count(*) as num_com\n    from codes_geographiques_communes as cgc\n    where cgc.\"TYPECOM\" = 'COM'\n    group by cgc.\"COM\"\n)\n\nselect *\nfrom counts\nwhere num_com > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.181685Z", "completed_at": "2024-04-25T00:24:38.183442Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.184544Z", "completed_at": "2024-04-25T00:24:38.184548Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.004911661148071289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_dep", "compiled": true, "compiled_code": "-- Test qu'il n'ya pas de doublons dans la table des codes g\u00e9ographiques des departements\n\nWITH counts as (\n    select \n        cgd.\"DEP\",\n        count(*) as num_dep\n    from codes_geographiques_departements as cgd\n    group by cgd.\"DEP\"\n)\n\nselect *\nfrom counts\nwhere num_dep > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.187858Z", "completed_at": "2024-04-25T00:24:38.189702Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.191104Z", "completed_at": "2024-04-25T00:24:38.191109Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005460977554321289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_price_mutation", "compiled": true, "compiled_code": "-- assert_value_for_mutation.sql\n\nWITH mutation_values AS (\n    SELECT \n        id_mutation,\n        code_commune,\n        code_postal,\n        latitude,\n        longitude,\n        valeur_fonciere\n    FROM \n        dvf\n),\n\nmutation_value_counts AS (\n    SELECT \n        id_mutation,\n        COUNT(DISTINCT valeur_fonciere) AS distinct_fonciere_count\n    FROM \n        mutation_values\n    GROUP BY \n        id_mutation\n)\n\nSELECT \n    id_mutation,\n    distinct_fonciere_count\nFROM \n    mutation_value_counts\nWHERE \n    distinct_fonciere_count > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.194826Z", "completed_at": "2024-04-25T00:24:38.196431Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.197744Z", "completed_at": "2024-04-25T00:24:38.197748Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0050847530364990234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_reg", "compiled": true, "compiled_code": "-- Test qu'il n'ya pas de doublons dans la table des codes g\u00e9ographiques des r\u00e9gions\n\nWITH counts as (\n    select \n        cgr.\"REG\",\n        count(*) as num_reg\n    from codes_geographiques_regions as cgr\n    group by cgr.\"REG\"\n)\n\nselect *\nfrom counts\nwhere num_reg > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.201080Z", "completed_at": "2024-04-25T00:24:38.203924Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.205032Z", "completed_at": "2024-04-25T00:24:38.205037Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005967140197753906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.test_knn", "compiled": true, "compiled_code": "-- Define expected values\nWITH expected AS (\n    SELECT 1 AS id, 250 AS expected_valeur UNION ALL\n    SELECT 3,       200 UNION ALL\n    SELECT 2,       150 UNION ALL\n    SELECT 4,       300 UNION ALL\n    SELECT 6,       250\n),\n\n-- Calculate knn for each row in the fake table\ncomputed AS (\n    \nWITH knn AS (\n    SELECT \n        a.id AS id,\n        AVG(b.valeur) AS mean_knn_value\n    FROM \n        \"test_db\".\"public\".\"fake_knn_data\" a\n        JOIN LATERAL (\n            SELECT valeur\n            FROM \"test_db\".\"public\".\"fake_knn_data\"\n            WHERE id != a.id\n            ORDER BY ST_SetSRID(ST_MakePoint(a.longitude, a.latitude), 4326) <-> ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)\n            LIMIT 2\n        ) b ON TRUE\n    GROUP BY a.id\n)\n\nSELECT \n    a.*,\n    b.mean_knn_value\nFROM \n    \"test_db\".\"public\".\"fake_knn_data\" a\n    JOIN knn b ON a.id = b.id\n\n)\n\n-- Compare computed and expected values\nSELECT \n    computed.id, \n    computed.mean_knn_value AS computed_valeur, \n    expected.expected_valeur\nFROM \n    computed\n    JOIN expected ON computed.id = expected.id\nWHERE\n    computed.mean_knn_value != expected.expected_valeur", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.208354Z", "completed_at": "2024-04-25T00:24:38.211232Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.212354Z", "completed_at": "2024-04-25T00:24:38.212359Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.006035327911376953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_geo_communes_number", "compiled": true, "compiled_code": "--- Le nombre officiel de communes en France est de 34935 en 2024\n--- https://www.collectivites-locales.gouv.fr/bulletin-dinformation-statistique-bis-de-la-dgcl\n\n\n\nwith source as (\n    SELECT COUNT(DISTINCT code_commune_insee) as commune_count\n    FROM \"test_db\".\"public\".\"geo_communes\"\n)\n\nselect *\nfrom source\nwhere commune_count != 34935", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.215682Z", "completed_at": "2024-04-25T00:24:38.218462Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.219612Z", "completed_at": "2024-04-25T00:24:38.219616Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005977630615234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.asset_geo_communes_distinct", "compiled": true, "compiled_code": "--- V\u00e9rifie que les communes du mod\u00e8le sont distinctes\n\n\n\nwith counts as (\n    SELECT code_commune_insee, COUNT(*) as num_com\n    FROM \"test_db\".\"public\".\"geo_communes\"\n    GROUP BY code_commune_insee\n)\n\nselect *\nfrom counts\nwhere num_com > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-25T00:24:38.222972Z", "completed_at": "2024-04-25T00:24:38.225721Z"}, {"name": "execute", "started_at": "2024-04-25T00:24:38.226883Z", "completed_at": "2024-04-25T00:24:38.226887Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005988121032714844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_geo_postaux_distinct", "compiled": true, "compiled_code": "--- V\u00e9rifie que les codes postaux du mod\u00e8le sont distincts\n\n\n\nwith counts as (\n    SELECT code_postal, COUNT(*) as num_cp\n    FROM \"test_db\".\"public\".\"geo_postaux\"\n    GROUP BY code_postal\n)\n\nselect *\nfrom counts\nwhere num_cp > 1", "relation_name": null}], "elapsed_time": 0.23143768310546875, "args": {"send_anonymous_usage_stats": true, "profiles_dir": ".", "use_colors_file": true, "version_check": true, "cache_selected_only": false, "quiet": false, "exclude": [], "log_file_max_bytes": 10485760, "partial_parse_file_diff": true, "enable_legacy_logger": false, "log_level": "info", "select": [], "project_dir": "/home/runner/work/make-open-data/make-open-data", "partial_parse": true, "invocation_command": "dbt docs generate", "print": true, "strict_mode": false, "static_parser": true, "log_level_file": "debug", "introspect": true, "favor_state": false, "log_path": "/home/runner/work/make-open-data/make-open-data/logs", "macro_debugging": false, "which": "generate", "log_format_file": "debug", "log_format": "default", "write_json": true, "empty_catalog": false, "printer_width": 80, "warn_error_options": {"include": [], "exclude": []}, "use_colors": true, "populate_cache": true, "indirect_selection": "eager", "vars": {}, "defer": false, "static": false, "compile": true, "show_resource_report": false}}