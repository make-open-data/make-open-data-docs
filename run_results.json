{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v5.json", "dbt_version": "1.7.10", "generated_at": "2024-04-24T09:19:40.032431Z", "invocation_id": "b692812c-3e73-4293-adaa-38951da01b1a", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.895512Z", "completed_at": "2024-04-24T09:19:39.901690Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.902870Z", "completed_at": "2024-04-24T09:19:39.902882Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.009657859802246094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.check_an_agg_for_cp", "compiled": true, "compiled_code": "-- Visualiser les dept et r\u00e9gion pour un CP multi d\u00e9partements\nselect\n    LPAD(CAST(cp.code_postal AS TEXT), 5, '0') as code_postal,\n    cc.\"COM\" as code_commune_insee,\n    cc.\"ARR\" as code_arrondissement,\n    cc.\"DEP\" as code_departement,\n    cc.\"REG\" as code_region\nfrom codes_postaux cp\nleft join codes_geographiques_communes cc on cp.code_commune_insee = cc.\"COM\" and cc.\"TYPECOM\" = 'COM'\nwhere code_postal = '01410'", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.906384Z", "completed_at": "2024-04-24T09:19:39.908117Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.909232Z", "completed_at": "2024-04-24T09:19:39.909238Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005133867263793945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.multiple_agg_per_cp", "compiled": true, "compiled_code": "-- Les departements et les r\u00e9gions sont donn\u00e9es par commune\n-- Il existe plusieurs codes postaux pour une commune et plusieurs communes pour un code postal\n-- Il convient de v\u00e9rifier que pour un code postal donn\u00e9, apr\u00e8s fusion avec la table communes,\n-- Il n'y a pas qu'un seul arrondissement, un seul d\u00e9partement et une seule r\u00e9gion\nwith merged_data as (\n    select\n        LPAD(CAST(cp.code_postal AS TEXT), 5, '0') as code_postal,\n        -- cc.\"ARR\" as code_arrondissement,\n        cc.\"DEP\" as code_departement,\n        cc.\"REG\" as code_region\n    from codes_postaux cp\n    inner join codes_geographiques_communes cc on cp.code_commune_insee = cc.\"COM\" and cc.\"TYPECOM\" = 'COM'\n    -- Remplacer par left join \u00e0 l'inclusions des territoire d'outre mer TOM \n    -- Puisque les codes communes ne sont pas renseign\u00e9s pour ces territoires dans codes_geographiques_communes\n    -- La R\u00e9union est une region d'outre, mais pas un territoire d'outre mer, d\u00e8s lors elle est incluse dans les codes_geographiques_communes\n),\n\ncounts as (\n    select \n        code_postal,\n        --count(distinct code_arrondissement) as num_arr,\n        count(distinct code_departement) as num_dep,\n        count(distinct code_region) as num_reg\n    from merged_data\n    group by code_postal\n)\n\nselect *\nfrom counts\nwhere num_dep > 1 or num_reg > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.912857Z", "completed_at": "2024-04-24T09:19:39.914488Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.915645Z", "completed_at": "2024-04-24T09:19:39.915650Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.004839897155761719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.multiple_com_per_cp", "compiled": true, "compiled_code": "--- Montre les codes postaux qui ont plusieurs codes communes\n\nSELECT code_postal, ARRAY_AGG(DISTINCT code_commune_insee) as communes\nFROM codes_postaux\nGROUP BY code_postal\nHAVING COUNT(DISTINCT code_commune_insee) > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.919005Z", "completed_at": "2024-04-24T09:19:39.920897Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.922016Z", "completed_at": "2024-04-24T09:19:39.922023Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005095720291137695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "analysis.makeopendata.multiple_cp_per_com", "compiled": true, "compiled_code": "--- Montre les communes qui ont plusieurs codes postaux\n\nSELECT code_commune_insee, ARRAY_AGG(DISTINCT code_postal) as postal_codes\nFROM codes_postaux\nGROUP BY code_commune_insee\nHAVING COUNT(DISTINCT code_postal) > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.925482Z", "completed_at": "2024-04-24T09:19:39.929009Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.930871Z", "completed_at": "2024-04-24T09:19:39.930878Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.00801992416381836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.fake_knn_data", "compiled": true, "compiled_code": "-- Pour tester la fonction knn, nous devons cr\u00e9er une table avec des donn\u00e9es fictives \n-- (impossible de faire des tests unitaires sur des donn\u00e9es qui ne sont pas dans une table). \n-- cr\u00e9e une fausse table avec id, latitude, longitude, et valeur columns\n-- S'assurer que le calcul ne se fait pas sur l'objet de la table\n\n\n\nWITH fake_knn_table AS (\n    SELECT 1 AS id, 43.7 AS latitude, 3.832 AS longitude, 100 AS valeur UNION ALL -- (3, 2) --> (200 + 300) / 2 = 250\n    SELECT 3,       43.7,             3.830,              200 UNION ALL -- (1, 2) --> (100 + 300) / 2 = 200\n    SELECT 2,       43.7,             3.831,              300 UNION ALL -- (1, 3) --> (100 + 200) / 2 = 150\n    SELECT 4,       43.7,             3.839,              400 UNION ALL -- (6, 1) --> (500 + 100) / 2 = 300\n    SELECT 6,       43.7,             3.838,              500  -- (4, 1) --> (400 + 100) / 2 = 250\n)\n\n\nselect * from fake_knn_table", "relation_name": "\"test_db\".\"public\".\"fake_knn_data\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.936280Z", "completed_at": "2024-04-24T09:19:39.939839Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.941152Z", "completed_at": "2024-04-24T09:19:39.941158Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.00784921646118164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.geo_communes", "compiled": true, "compiled_code": "/*\n    Merge all data to commune level\n\n\n    Try changing \"table\" to \"view\" below\n*/\n\n\n\nwith filtered_codes_geographiques_communes as (\n    -- Filter out non-commune rows here to avoid confusion of filtering in the main query\n    select * \n    from codes_geographiques_communes     \n    where codes_geographiques_communes.\"TYPECOM\" = 'COM' \n\n), source_data as (\n\n    select\n        f_cgc.\"COM\" as code_commune_insee,\n        f_cgc.\"LIBELLE\" as nom_commune,\n        f_cgc.\"REG\" as code_region,\n        cgr.\"LIBELLE\" as nom_region,\n        f_cgc.\"DEP\" as code_departement,\n        cgd.\"LIBELLE\" as nom_departement,\n        f_cgc.\"ARR\" as code_arrondissement,\n        cga.\"LIBELLE\" as nom_arrondissement\n    from filtered_codes_geographiques_communes f_cgc \n    left join codes_geographiques_arrondissements cga on f_cgc.\"ARR\" = cga.\"ARR\" \n    left join codes_geographiques_departements cgd on f_cgc.\"DEP\" = cgd.\"DEP\" \n    left join codes_geographiques_regions cgr on f_cgc.\"REG\" = cgr.\"REG\"     \n), geopoints as (\n    select DISTINCT\n        LPAD(CAST(cp.code_commune_insee AS TEXT), 5, '0') as code_commune_insee,\n        CAST(SPLIT_PART(cp._geopoint, ',', 1) AS FLOAT) as commune_latitude,\n        CAST(SPLIT_PART(cp._geopoint, ',', 2) AS FLOAT) as commune_longitude\n    from codes_postaux cp\n)\n\nselect\n    sd.*,\n    gp.commune_latitude,\n    gp.commune_longitude\nfrom source_data sd\nleft join geopoints gp on sd.code_commune_insee = gp.code_commune_insee", "relation_name": "\"test_db\".\"public\".\"geo_communes\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.945049Z", "completed_at": "2024-04-24T09:19:39.948660Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.949780Z", "completed_at": "2024-04-24T09:19:39.949786Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0070343017578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.geo_postaux", "compiled": true, "compiled_code": "/*\n    Merge all data to commune level\n\n\n    Try changing \"table\" to \"view\" below\n*/\n\n\n\nwith source_data as (\n    select DISTINCT\n        LPAD(CAST(code_postal AS TEXT), 5, '0') as code_postal,\n        CASE \n            WHEN SUBSTRING(LPAD(CAST(code_postal AS TEXT), 5, '0') for 3) IN ('200', '201') THEN '2A'\n            WHEN SUBSTRING(LPAD(CAST(code_postal AS TEXT), 5, '0') for 1) = '2' THEN '2B'\n            ELSE SUBSTRING(LPAD(CAST(code_postal AS TEXT), 5, '0') for 2)\n        END as code_departement\n    from codes_postaux\n),\n\njoined_with_departement as (\n    select \n        sd.*,\n        cd.\"LIBELLE\" as nom_departement,\n        cd.\"REG\" as code_region\n    from source_data sd\n    left join codes_geographiques_departements cd on sd.code_departement = cd.\"DEP\"\n),\n\njoined_with_region as (\n    select \n        jd.*,\n        cr.\"LIBELLE\" as nom_region\n    from joined_with_departement jd\n    left join codes_geographiques_regions cr on jd.code_region = cr.\"REG\"\n)\n\nselect *\nfrom joined_with_region", "relation_name": "\"test_db\".\"public\".\"geo_postaux\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.954162Z", "completed_at": "2024-04-24T09:19:39.956861Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.958016Z", "completed_at": "2024-04-24T09:19:39.958022Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.006315469741821289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.geo_postaux_communes", "compiled": true, "compiled_code": "--- Un code postal peut appartenir \u00e0 plusieurs communes\n--- Une code commune insee peut appartenir plusieurs codes postaux\n--- On cr\u00e9e une table de passage pour avoir une relation unique entre les codes postaux et les codes communes insee\n\n\n\nwith unique_codes_communes_postaux as (\n    select DISTINCT\n        LPAD(CAST(code_postal AS TEXT), 5, '0') as code_postal,\n        code_commune_insee\n    from codes_postaux\n)\n\nselect *\nfrom unique_codes_communes_postaux", "relation_name": "\"test_db\".\"public\".\"geo_postaux_communes\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.961448Z", "completed_at": "2024-04-24T09:19:39.964392Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.965514Z", "completed_at": "2024-04-24T09:19:39.965520Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.007905244827270508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.makeopendata.immo_dvf_mutations", "compiled": true, "compiled_code": "-- Filtres nature transaction et nature bien :\n-- Il convient aussi de garder que les vente (explure les VEFA et les \u00e9changes)\n-- Et que les transactions qui concernent au moins un appartement et les maisons\n\n-- Filtres sur les surfaces et trautement des pi\u00e8ces :\n-- Il convient de garder que les transactions qui concernent des biens de plus de 9m2 \n-- Le nombre de pi\u00e8ces est souvent mal renseign\u00e9, il convient de le corriger en fonction de la surface\n\n-- Filtres sur les prix :\n-- Il convient de garder que les transactions dont le prix au metre carr\u00e9 n'est pas 50% de plus que ses 10 plus proches voisins\n\n-- Donn\u00e9es par mutation : \n-- Les donn\u00e9es DVF sont initilement pr\u00e9sent\u00e9es sous forme d'une ligne par mutation (transaction)\n-- Une mutation peut concerner plusieurs biens\n-- Le prix est le prix total de la mutation, il apparait sur les biens concern\u00e9s\n\n\n\nWITH filtered_dvf AS (\n    SELECT \n        id_mutation,\n        valeur_fonciere,\n        longitude,\n        latitude,\n        nombre_pieces_principales,\n        surface_reelle_bati,\n        type_local,\n        LPAD(CAST(code_postal AS TEXT), 5, '0') as code_postal,\n        code_commune\n    FROM \n        dvf\n    WHERE \n        EXISTS (\n            SELECT 1\n            FROM dvf d1\n            WHERE d1.id_mutation = dvf.id_mutation AND d1.type_local IN ('Appartement', 'Maison')\n        ) AND\n        NOT EXISTS (\n            SELECT 1\n            FROM dvf d2\n            WHERE d2.id_mutation = dvf.id_mutation AND d2.nature_mutation != 'Vente'\n        )\n),\nsums AS (\n    SELECT \n        id_mutation,\n        SUM(surface_reelle_bati) AS total_surface,\n        SUM(nombre_pieces_principales) AS total_pieces\n    FROM \n        filtered_dvf\n    GROUP BY \n        id_mutation\n),\n\nranked_dvf AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (\n            PARTITION BY id_mutation\n            ORDER BY \n                CASE WHEN type_local = 'Maison' THEN 1\n                     WHEN type_local = 'Appartement' THEN 2\n                     ELSE 3\n                END,\n                surface_reelle_bati DESC\n        ) AS rn\n    FROM \n        filtered_dvf\n)\n\nSELECT \n    r.id_mutation,\n    r.valeur_fonciere,\n    r.longitude,\n    r.latitude,\n    s.total_pieces,\n    s.total_surface,\n    r.type_local,\n    r.code_postal,\n    r.code_commune\nFROM \n    ranked_dvf r\nJOIN \n    sums s ON r.id_mutation = s.id_mutation\nWHERE \n    r.rn = 1", "relation_name": "\"test_db\".\"public\".\"immo_dvf_mutations\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.970756Z", "completed_at": "2024-04-24T09:19:39.972614Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.973730Z", "completed_at": "2024-04-24T09:19:39.973734Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005055427551269531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_arr", "compiled": true, "compiled_code": "-- Test qu'il n'ya pas de doublons dans la table des codes g\u00e9ographiques des arrondissements\n\nWITH counts as (\n    select \n        cga.\"ARR\",\n        count(*) as num_arr\n    from codes_geographiques_arrondissements as cga\n    group by cga.\"ARR\"\n)\n\nselect *\nfrom counts\nwhere num_arr > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.977106Z", "completed_at": "2024-04-24T09:19:39.978965Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.980109Z", "completed_at": "2024-04-24T09:19:39.980114Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0050580501556396484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_com", "compiled": true, "compiled_code": "-- Une commune peut avoir plusieurs types\n-- COM\tCommune / COMA\tCommune associ\u00e9e / COMD\tCommune d\u00e9l\u00e9gu\u00e9e / ARM\tArrondissement municipal\n-- Les COM sont celles existantes, les autres types sont des legacy de fusions ou disparitions de communes\n\nWITH counts as (\n    select \n        cgc.\"COM\",\n        count(*) as num_com\n    from codes_geographiques_communes as cgc\n    where cgc.\"TYPECOM\" = 'COM'\n    group by cgc.\"COM\"\n)\n\nselect *\nfrom counts\nwhere num_com > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.983473Z", "completed_at": "2024-04-24T09:19:39.985235Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.986340Z", "completed_at": "2024-04-24T09:19:39.986345Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.004972934722900391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_dep", "compiled": true, "compiled_code": "-- Test qu'il n'ya pas de doublons dans la table des codes g\u00e9ographiques des departements\n\nWITH counts as (\n    select \n        cgd.\"DEP\",\n        count(*) as num_dep\n    from codes_geographiques_departements as cgd\n    group by cgd.\"DEP\"\n)\n\nselect *\nfrom counts\nwhere num_dep > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.989700Z", "completed_at": "2024-04-24T09:19:39.991603Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.992743Z", "completed_at": "2024-04-24T09:19:39.992748Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005146503448486328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_price_mutation", "compiled": true, "compiled_code": "-- assert_value_for_mutation.sql\n\nWITH mutation_values AS (\n    SELECT \n        id_mutation,\n        code_commune,\n        code_postal,\n        latitude,\n        longitude,\n        valeur_fonciere\n    FROM \n        dvf\n),\n\nmutation_value_counts AS (\n    SELECT \n        id_mutation,\n        COUNT(DISTINCT valeur_fonciere) AS distinct_fonciere_count\n    FROM \n        mutation_values\n    GROUP BY \n        id_mutation\n)\n\nSELECT \n    id_mutation,\n    distinct_fonciere_count\nFROM \n    mutation_value_counts\nWHERE \n    distinct_fonciere_count > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:39.996126Z", "completed_at": "2024-04-24T09:19:39.997782Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:39.999130Z", "completed_at": "2024-04-24T09:19:39.999135Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.005097389221191406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_one_reg", "compiled": true, "compiled_code": "-- Test qu'il n'ya pas de doublons dans la table des codes g\u00e9ographiques des r\u00e9gions\n\nWITH counts as (\n    select \n        cgr.\"REG\",\n        count(*) as num_reg\n    from codes_geographiques_regions as cgr\n    group by cgr.\"REG\"\n)\n\nselect *\nfrom counts\nwhere num_reg > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:40.002576Z", "completed_at": "2024-04-24T09:19:40.005694Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:40.006820Z", "completed_at": "2024-04-24T09:19:40.006825Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0064737796783447266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.test_knn", "compiled": true, "compiled_code": "-- Define expected values\nWITH expected AS (\n    SELECT 1 AS id, 250 AS expected_valeur UNION ALL\n    SELECT 3,       200 UNION ALL\n    SELECT 2,       150 UNION ALL\n    SELECT 4,       300 UNION ALL\n    SELECT 6,       250\n),\n\n-- Calculate knn for each row in the fake table\ncomputed AS (\n    \nWITH knn AS (\n    SELECT \n        a.id AS id,\n        AVG(b.valeur) AS mean_knn_value\n    FROM \n        \"test_db\".\"public\".\"fake_knn_data\" a\n        JOIN LATERAL (\n            SELECT valeur\n            FROM \"test_db\".\"public\".\"fake_knn_data\"\n            WHERE id != a.id\n            ORDER BY ST_SetSRID(ST_MakePoint(a.longitude, a.latitude), 4326) <-> ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)\n            LIMIT 2\n        ) b ON TRUE\n    GROUP BY a.id\n)\n\nSELECT \n    a.*,\n    b.mean_knn_value\nFROM \n    \"test_db\".\"public\".\"fake_knn_data\" a\n    JOIN knn b ON a.id = b.id\n\n)\n\n-- Compare computed and expected values\nSELECT \n    computed.id, \n    computed.mean_knn_value AS computed_valeur, \n    expected.expected_valeur\nFROM \n    computed\n    JOIN expected ON computed.id = expected.id\nWHERE\n    computed.mean_knn_value != expected.expected_valeur", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:40.010245Z", "completed_at": "2024-04-24T09:19:40.013182Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:40.014307Z", "completed_at": "2024-04-24T09:19:40.014312Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.006146669387817383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_geo_communes_number", "compiled": true, "compiled_code": "--- Le nombre officiel de communes en France est de 34935 en 2024\n--- https://www.collectivites-locales.gouv.fr/bulletin-dinformation-statistique-bis-de-la-dgcl\n\n\n\nwith source as (\n    SELECT COUNT(DISTINCT code_commune_insee) as commune_count\n    FROM \"test_db\".\"public\".\"geo_communes\"\n)\n\nselect *\nfrom source\nwhere commune_count != 34935", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:40.017658Z", "completed_at": "2024-04-24T09:19:40.020483Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:40.021612Z", "completed_at": "2024-04-24T09:19:40.021617Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.006004810333251953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.asset_geo_communes_distinct", "compiled": true, "compiled_code": "--- V\u00e9rifie que les communes du mod\u00e8le sont distinctes\n\n\n\nwith counts as (\n    SELECT code_commune_insee, COUNT(*) as num_com\n    FROM \"test_db\".\"public\".\"geo_communes\"\n    GROUP BY code_commune_insee\n)\n\nselect *\nfrom counts\nwhere num_com > 1", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-04-24T09:19:40.024990Z", "completed_at": "2024-04-24T09:19:40.027844Z"}, {"name": "execute", "started_at": "2024-04-24T09:19:40.028967Z", "completed_at": "2024-04-24T09:19:40.028971Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0060384273529052734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.makeopendata.assert_geo_postaux_distinct", "compiled": true, "compiled_code": "--- V\u00e9rifie que les codes postaux du mod\u00e8le sont distincts\n\n\n\nwith counts as (\n    SELECT code_postal, COUNT(*) as num_cp\n    FROM \"test_db\".\"public\".\"geo_postaux\"\n    GROUP BY code_postal\n)\n\nselect *\nfrom counts\nwhere num_cp > 1", "relation_name": null}], "elapsed_time": 0.24142837524414062, "args": {"indirect_selection": "eager", "printer_width": 80, "log_level_file": "debug", "use_colors": true, "static": false, "vars": {}, "partial_parse_file_diff": true, "empty_catalog": false, "enable_legacy_logger": false, "which": "generate", "partial_parse": true, "send_anonymous_usage_stats": true, "log_level": "info", "introspect": true, "profiles_dir": ".", "populate_cache": true, "use_colors_file": true, "log_path": "/home/runner/work/make-open-data/make-open-data/logs", "cache_selected_only": false, "log_format_file": "debug", "write_json": true, "defer": false, "project_dir": "/home/runner/work/make-open-data/make-open-data", "static_parser": true, "log_file_max_bytes": 10485760, "macro_debugging": false, "show_resource_report": false, "compile": true, "strict_mode": false, "print": true, "log_format": "default", "version_check": true, "warn_error_options": {"include": [], "exclude": []}, "quiet": false, "select": [], "invocation_command": "dbt docs generate", "exclude": [], "favor_state": false}}